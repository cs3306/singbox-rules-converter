name: Update SingBox Rules

on:
  schedule:
    - cron: '0 0 * * *'  # 每天运行一次
  workflow_dispatch:     # 允许手动触发

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'
          
      - name: Install SingBox CLI
        run: |
          go install -v github.com/sagernet/sing-box/cmd/sing-box@latest
          
      - name: Clone source repositories
        run: |
          # 克隆 ACL4SSR 仓库
          git clone --depth 1 https://github.com/ACL4SSR/ACL4SSR.git temp/ACL4SSR
          
          # 克隆 blackmatrix7 仓库
          git clone --depth 1 https://github.com/blackmatrix7/ios_rule_script.git temp/blackmatrix7
          
      - name: Create Python conversion script
        run: |
          cat > convert_rules.py << 'EOF'
#!/usr/bin/env python3
import yaml
import json
import sys
import os
import glob
from pathlib import Path

def get_outbound(category, filename):
    """根据规则类别和文件名决定出站策略"""
    filename = filename.lower()
    
    # 广告拦截规则
    if any(keyword in filename for keyword in ['ad', 'ads', 'advert', 'advertising', 'ban', 'reject', 'privacy']):
        return "block"
    
    # 直连规则
    if any(keyword in filename for keyword in ['china', 'cn', 'direct', 'mainland', 'domestic']):
        return "direct"
    
    # 默认为代理
    return "proxy"

def convert_clash_yaml_to_singbox(input_file, output_file, outbound):
    """转换YAML格式的Clash规则到SingBox规则集"""
    # 创建SingBox规则集基础结构
    singbox_data = {
        "version": 3,
        "rules": []
    }
    
    # 读取并解析YAML文件
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            try:
                clash_data = yaml.safe_load(f)
            except yaml.YAMLError as e:
                print(f"Error parsing YAML file {input_file}: {e}")
                return False
        
        # 提取规则
        rules = clash_data.get('payload', [])
        if not rules:
            print(f"No rules found in {input_file}")
            return False
        
        # 处理每条规则
        for rule in rules:
            parts = rule.split(',')
            if len(parts) < 2:
                continue
            
            rule_type = parts[0]
            value = parts[1]
            
            singbox_rule = {
                "outbound": outbound
            }
            
            # 根据规则类型设置正确的SingBox规则类型和值
            if rule_type == 'DOMAIN-SUFFIX':
                singbox_rule["domain_suffix"] = [value]
            elif rule_type == 'DOMAIN-KEYWORD':
                singbox_rule["domain_keyword"] = [value]
            elif rule_type == 'DOMAIN':
                singbox_rule["domain"] = [value]
            elif rule_type == 'IP-CIDR':
                singbox_rule["ip_cidr"] = [value]
            elif rule_type == 'IP-CIDR6':
                singbox_rule["ip_cidr"] = [value]
            else:
                # 跳过不支持的规则类型
                continue
            
            # 添加到规则列表
            singbox_data["rules"].append(singbox_rule)
        
        # 保存为JSON
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(singbox_data, f, indent=2, ensure_ascii=False)
        
        print(f"Successfully converted {input_file} to {output_file}")
        return True
    except Exception as e:
        print(f"Error processing file {input_file}: {e}")
        return False

def convert_dir(input_dir, output_dir, source_name):
    """处理整个目录的规则文件"""
    success_count = 0
    fail_count = 0
    
    # 查找所有YAML规则文件
    yaml_files = []
    for ext in ["*.yaml", "*.yml"]:
        yaml_files.extend(glob.glob(os.path.join(input_dir, "**", ext), recursive=True))
    
    print(f"Found {len(yaml_files)} YAML files in {input_dir}")
    
    for yaml_file in yaml_files:
        # 判断这个文件是否是规则文件
        try:
            with open(yaml_file, 'r', encoding='utf-8') as f:
                content = yaml.safe_load(f)
                if not isinstance(content, dict) or 'payload' not in content:
                    # 不是规则文件，跳过
                    continue
        except:
            # 无法解析，跳过
            continue
        
        # 构建输出文件路径
        rel_path = os.path.relpath(yaml_file, input_dir)
        category = os.path.dirname(rel_path).replace("\\", "/")
        filename = os.path.basename(yaml_file).split('.')[0]
        
        output_json = os.path.join(output_dir, source_name, category, f"{filename}.json")
        
        # 确定出站策略
        outbound = get_outbound(category, filename)
        
        # 转换文件
        if convert_clash_yaml_to_singbox(yaml_file, output_json, outbound):
            success_count += 1
        else:
            fail_count += 1
    
    print(f"Conversion complete: {success_count} succeeded, {fail_count} failed")
    return success_count

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python convert_rules.py <input_dir> <output_dir> <source_name>")
        sys.exit(1)
    
    input_dir = sys.argv[1]
    output_dir = sys.argv[2]
    source_name = sys.argv[3]
    
    count = convert_dir(input_dir, output_dir, source_name)
    print(f"Successfully converted {count} rule files from {source_name}")
EOF
          
          chmod +x convert_rules.py
          
      - name: Convert ACL4SSR rules
        run: |
          mkdir -p output
          # 转换ACL4SSR Clash规则
          python3 convert_rules.py temp/ACL4SSR/Clash output acl4ssr
          python3 convert_rules.py temp/ACL4SSR/Clash/Providers output acl4ssr-providers
          
      - name: Convert BlackMatrix7 rules
        run: |
          # 转换BlackMatrix7 Clash规则
          python3 convert_rules.py temp/blackmatrix7/rule/Clash output blackmatrix7
          
      - name: Generate binary rule sets
        run: |
          # 递归查找所有JSON文件并编译为二进制规则集
          find output -type f -name "*.json" | while read -r file; do
            dir=$(dirname "$file")
            filename=$(basename "$file" .json)
            echo "Compiling $file to $dir/${filename}.srs"
            sing-box rule-set compile --output "$dir/${filename}.srs" "$file"
          done
          
      - name: Create README
        run: |
          cat > README.md << 'EOF'
# SingBox Rules

这个仓库包含了从常用的Clash规则源自动转换生成的SingBox规则集。

## 规则来源

- [ACL4SSR/ACL4SSR](https://github.com/ACL4SSR/ACL4SSR)
- [blackmatrix7/ios_rule_script](https://github.com/blackmatrix7/ios_rule_script)

## 使用方法

在SingBox配置中添加规则集：

```json
{
  "route": {
    "rule_set": [
      {
        "tag": "规则名称",
        "type": "remote",
        "format": "binary",
        "url": "https://raw.githubusercontent.com/你的用户名/singbox-rules-converter/main/output/来源/规则类别/规则名称.srs",
        "download_detour": "proxy"
      }
    ],
    "rules": [
      {
        "rule_set": ["规则名称"],
        "outbound": "proxy或direct或block"
      }
    ]
  }
}
```

## 自动更新

规则每天自动更新一次。也可以手动触发GitHub Actions工作流来更新规则。
EOF
          
          # 更新README中当前可用的规则列表
          echo -e "\n## 可用规则列表\n" >> README.md
          
          # ACL4SSR 规则
          echo -e "\n### ACL4SSR 规则\n" >> README.md
          find output/acl4ssr -type f -name "*.srs" | sort | while read -r file; do
            rel_path=$(realpath --relative-to=output "$file")
            echo "- [$rel_path](https://raw.githubusercontent.com/$GITHUB_REPOSITORY/main/output/$rel_path)" >> README.md
          done
          
          # ACL4SSR Providers 规则
          echo -e "\n### ACL4SSR Providers 规则\n" >> README.md
          find output/acl4ssr-providers -type f -name "*.srs" | sort | while read -r file; do
            rel_path=$(realpath --relative-to=output "$file")
            echo "- [$rel_path](https://raw.githubusercontent.com/$GITHUB_REPOSITORY/main/output/$rel_path)" >> README.md
          done
          
          # BlackMatrix7 规则
          echo -e "\n### BlackMatrix7 规则\n" >> README.md
          find output/blackmatrix7 -type f -name "*.srs" | sort | while read -r file; do
            rel_path=$(realpath --relative-to=output "$file")
            echo "- [$rel_path](https://raw.githubusercontent.com/$GITHUB_REPOSITORY/main/output/$rel_path)" >> README.md
          done
          
      - name: Commit and push changes
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          git add output/ README.md
          
          # 检查是否有变更需要提交
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "Update SingBox rules [automated]"
          git push
